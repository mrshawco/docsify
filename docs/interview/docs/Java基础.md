## 1. 遍历Map的几种方法？

一般情况下，entrySet 性能上要优于 keySet，因为 keySet 需要从 map 中再次根据 key 获取 value，这一种也是最常用的遍历方法，遍历方法 foreach 的语法只是对 iterator 进行了简单的包装，iterator 能对集合中元素进行删除操，foreach 循环进行删除添加操作会报错。

## 2. HashMap的特性？

**数组**：采用一段连续的存储单元来存储数据,查询快,删除/插入慢。

**单向链表/双向链表**：是一种线性表，但是并不会在物理存储上按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针（Pointer）/头尾节点指针。插入和删除非常快，查询慢。

![1664696221242](https://s2.loli.net/2022/10/13/8FL5CzA12aUxWvn.png)

**二叉树**：对一棵相对平衡的有序二叉树，每棵子树头节点的值都比各自左子树上所有节点值要大，也都比各自右子树上所有节点值要小。二叉查找树的中序遍历序列一定是从小到大排列的。

![1664696179551](https://s2.loli.net/2022/10/13/GFTDcNAJSzPKQew.png)

**哈希表**：哈希表（Hash Table）又称为散列表。Hash 表是一种根据关键字值（key - value）而直接进行访问的数据结构。它基于数组，通过把关键字映射（哈希函数）到数组的某个下标来加快查找速度（类似于拼音字典）。相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成。

![1664696227498](https://s2.loli.net/2022/10/13/vRu17h9FQynCrdb.png)

**HashMap 的分析：**

- HashMap 是可以序列化的。是线程不安全的。
- HashMap 的底层主要是基于数组和链表实现的，它之所以有相当快的查询速度主要是因为它是通过计算散列码来决定存储位置的。
- HashMap 中主要是通过 key 的 hashCode 来计算 hash 值，然后通过 hash 值选择不同的数组来存储。只要  hashCode 相同，计算出来的 hash 值就一样，如果存储对象多了，就有可能不同的对象计算出来的 hash 值是相同的，这就出现了所谓的 hash 冲突，HashMap 的底层是通过链表来解决 hash 冲突的。具体就是把相同 hash 值的 HashMap，通过链表的形式进行存储，相当于存储的数组就是哈希表，数组的每个元素都是一个单链表的头结点，链表是用来解决 hash 冲突的，如果不同的 key 映射到了数组的同一位置，那么就将其放 入单链表中。
  ![1664696387508](https://s2.loli.net/2022/10/13/786qka1QbDluZFy.png)
- HashMap 不是同步，Hashtable 是同步的，但 Hashtable 已经弃用，如果需要线程安全，可以用 synchronizedMap，例如`Map m = Collections.synchronizedMap(new HashMap(...));`。

## 3. Hashtable 与 HashMap 有什么不同之处？

- 两者最主要的区别在于 Hashtable 是线程安全，而 HashMap 则非线程安全。Hashtable 的实现方法都添加了 synchronized 来确保线程同步，HashMap 性能会高一些。
- HashMap 可以使用 null 作为 key，这样的键只有一个；可以有一个或多个键所对应的值为 null，不过建议还是尽量避免这样使用。HashMap 以 null 作为 key 时，总是存储在 table 数组的第一个节点上。而 Hashtable 则不允许 null 作为 key。
- HashMap 的初始容量为16，Hashtable 初始容量为11，两者的填充因子默认都是0.75。
- HashMap 和 Hashtable 的底层实现都是数组 + 链表结构实现。

## 4. LinkedList 和 ArrayList 区别？

- ArrayList 是实现了基于动态数组的数据结构，LinkedList 基于链表的数据结构。
- 对于随机访问 get 和 set，ArrayList 觉得优于 LinkedList，因为 LinkedList 要移动指针。
- 对于新增和删除操作 add 和 remove ，LinedList 比较占优势，因为 ArrayList 要移动数据。
- 所以在我们进行对元素的增删查操作的时候，进行查操作时用 ArrayList，进行增删操作的时候最好用 LinkedList。

## 5. Java 虚拟机中的内存模型？

- **方法区**：方法区用于存储被虚拟机加载的类信息、常量、static变量等数据。字符串常量池就位于方法区。 
- **堆**：堆用于存储对象实例，java 中通 new 创建的对象实例就保存在堆中。
- **虚拟机栈**：虚拟机栈用于实现方法调用，每次方法调用就对应栈中的一个栈帧，栈帧包含**局部变量表**、**操作数栈**、**方法接口**等于方法相关的信息。 
- **本地方法栈**：本地方法栈类似于虚拟机栈，只是保存的是本地方法（其他语言实现的系统方法）的调用。 
- **程序计数器**：程序计数器的功能相当于PC寄存器的功能，如果当前执行的是 Java 方法，则指示当前字节码指令的地址，如果执行的是本地本地方法，则值为 Undefined。

![1664719956816](https://s2.loli.net/2022/10/13/SoQMxEKLnWCwgzt.png)

## 6. 简单说说 Java 中的异常处理机制的简单原理和应用。

异常分类，异常举例，异常处理

## 7. 创建线程的几种方式？

Java 使用 Thread 类代表线程，所有的线程对象都必须是 Thread 类或其子类的实例。创建线程的方式如下4种：

1. **继承 Thread 类创建线程**`MyThread extends Thread{} new MyThread().start();//创建并启动线程`

2. **实现 Runnable 接口创建线程**`MyThread2 implements Runnable {} new Thread(new MyThread2()).start();`

3. **使用 Callable 和 Future 创建线程**
   - 和 Runnable 接口不一样，Callable 接口提供了一个 call 方法作为线程执行体，call() 方法比 run() 方法功能要强大,可以有返回值和声明异常抛出。
   - V get()：返回 Callable 里 call 方法的返回值，调用这个方法会导致程序阻塞，必须等到子线程结束后才会得到返回值。
   - V get(long timeout,TimeUnit unit)：返回 Callable 里 call 方法的返回值，最多阻塞 timeout 时间，经过指定时间没有返回抛出 TimeoutException。
   - boolean isDone()：若 Callable 任务完成，返回 True。
   - boolean isCancelled()：如果在 Callable 任务正常完成前被取消，返回 True。
   
4. **使用线程池**
   - Executor 接口的最大优点是把任务的提交和执行解耦。要执行任务的人只需把 Task 描述清楚，然后提交即可。这个 Task 是怎么被执行的，被谁执行的，什么时候执行的，提交的人就不用关心了。
   - ExecutorService 子实现接口
     - void shutdown() 启动有序关闭，其中先前提交的任务将被执行，但不会接受任何新任务。
     - Future<?> submit(Runnable task) 提交一个可运行的任务执行。
   - newFixedThreadPool(int) 任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子
   - SingleThreadExecutor() 单例线程，任意时间池中只能有一个线程。

## 8. Java 中 sleep 和 wait 的区别？

![1664721710508](https://s2.loli.net/2022/10/13/ohzdJkbDRljSq1g.png)

- sleep 方法是 Thread 类的静态方法，wait() 是 Object 超类的成员方法。
- sleep() 方法导致了程序暂停执行指定的时间，让出 cpu 该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。在调用 sleep() 方法的过程中，线程不会释放对象锁。
- 而当调用 wait() 方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用 notify() 方法后本线程才进入对象锁定池准备。
- sleep 方法需要抛异常，wait 方法不需要，Thread 类中 sleep 方法就已经进行了抛异常处理 sleep 方法可以在任何地方使用，wait 方法只能在同步方法和同步代码块中使用。

## 9. 实现一个线程有哪几种方式，各有什么优缺点，比较常用的是那种？

- 继承 Thread 类 优点：代码简单。缺点：该类无法集成别的类。 
- 实现 Runnable 接口 优点：继承其他类。 同一实现该接口的实例可以共享资源。缺点：代码复杂。
- 实现 Callable 优点：可以获得异步任务的返回值。
- 线程池 优点：实现自动化装配，易于管理，循环利用资源。

## 10. 多线程解决同步问题的方式？

同步代码块(推荐) 同步方法 锁机制 继承 runnable 接口 lock() : 获得锁 / unlock() : 释放锁

## 11. 谈谈你对垃圾回收机制的了解？

> C的垃圾回收是人工的，工作量大，但是可控性高。Java 是自动化的，但是可控性很差，甚至有时会出现内存溢出的情况，内存溢出也就是 Jvm 分配的内存中对象过多，超出了最大可分配内存的大小。

Java 程序员在编写程序的时候不在考虑内存管理。由于有个垃圾回收机制，Java 中的额外对象不再有”作用域“的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。

内存泄露：指该内存空间使用完毕后未回收，也就是一个内存对象的生命周期超出了程序需要它的时间长度，我们有是也将其称为“对象游离”。在 Java 中是通过引用来和对象进行关联的，也就是说如果要操作对象，必须通过引用来进行。那么很显然一个简单的办法就是通过引用计数来判断一个对象是否可以被回收。不失一般性，如果一个对象没有任何引用与之关联，则说明该对象基本不太可能在其他地方被使用到，那么这个对象就成为可被回收的对象了。

> Jvm 会在什么时候进行回收 :
>
> - 会在 cpu 空闲的时候自动进行回收
> - 在堆内存存储满了之后
> - 主动调用 System.gc() 后尝试进行回收

## 12. 类加载机制有了解吗？

1. **装载**：查找和导入 Class 文件；

2. **链接**：把类的二进制数据合并到 JRE 中； 
- **校验**：检查载入Class文件数据的正确性； 
   
- **准备**：给类的静态变量分配存储空间； 
   
- **解析**：将符号引用转成直接引用；
   
3. **初始化**：对类的静态变量，静态代码块执行初始化操作。

系统给我们提供的类加载器有三种：启动类加载器、扩展类加载器和系统类加载器。

- **启动类（Bootstrap）加载器**：它是由 C++ 实现的本地方法，不属于 Java 类范畴，不能够被直接引用，主要被用于加载 Java 所需的核心 jar 包，它负责将 <JAVA_HOME>/lib 路径下的核心类库或 -Xbootclasspath 参数指定的路径下的 jar 包加载到内存中，属于顶级类加载器。
- **扩展类（Extension）加载器**： 它负责加载 <JAVA_HOME>/lib/ext 目录下或者由系统变量 -Djava.ext.dir 指定位路径中的类库。
- **系统类（System）加载器**： 它负责加载系统类路径 java -classpath 或 -D java.class.path 指定路径下的类库，也就是我们经常用到的 classpath 路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过 ClassLoader#getSystemClassLoader() 方法可以获取到该类加载器。

![1664798036161](https://s2.loli.net/2022/10/13/xy6Vkp1vdjBFDmO.png)

![1664798056513](https://s2.loli.net/2022/10/13/xAIXfnMml5udwrq.png)

## 13. 说说 HashCode()、equals() 的区别？

hashCode() 方法和 equal() 方法的作用其实一样，在 Java 里都是用来对比两个对象是否相等一致，那么 equal() 既然已经能实现对比的功能了，为什么还要 hashCode() 呢？

因为重写的 equal() 里一般比较全面比较复杂，这样效率就比较低，而利用 hashCode() 进行对比，则只要生成一个 hash 值进行比较就可以了，效率很高，那么 hashCode() 既然效率这么高为什么还要 equal() 呢？

因为 hashCode() 并不是完全可靠，有时候不同的对象他们生成的 hashcode 也会一样（生成 hash 值得公式可能存在的问题），所以 hashCode() 只能说是大部分时候可靠，并不是绝对可靠，所以我们可以得出：

- equal() 相等的两个对象他们的 hashCode() 肯定相等，也就是用 equal() 对比是绝对可靠的。
- hashCode() 相等的两个对象他们的 equal() 不一定相等，也就是 hashCode() 不是绝对可靠的。

所有对于需要大量并且快速的对比的话如果都用 equal() 去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用 hashCode() 去对比，如果 hashCode() 不一样，则表示这两个对象肯定不相等（也就是不必再用 equal() 去再对比了），如果 hashCode() 相同，此时再对比他们的 equal() ，如果 equal() 也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！

## 14. String，StringBuilder，StringBuffer 三者的区别？

String：不可变字符串，如果要操作少量的数据用 String。 

StringBuffer：可变字符串、效率低、线程安全。

StringBuilder：可变字符串、效率高、线程不安全。

## 15. 是否可以从一个 static 方法内部发出对非 static 方法的调用？

## 16. `String s = new String("xyz"); `创建了几个 String Object？是否可以继承 String 类？

创建对象只要是 new，都是重新分配堆空间，如果不区分栈和堆，这里创建了1个 String Object。如果是从 Jvm 角度来说的话，它是创建了两个对象，String s 是在栈里创建了一个变量，`new String("xyz")`是在堆里创建了一个对象并被 s 引用到。 如果是`String s = "xyz"`，那就要看常量池里有没有 "xyz"，如果有直接引用，如果没有则创建再引用。

String 类是 final 修饰的不可变类,其它类不可以继承 String 类。

## 17. `String s = "hello"; s = s + "world!";`这两行代码执行后，原始的 String 对象中的内容到底变了没有？

没有,因为 String 被设计为不可变类，所以它的所有对象都是不可变的对象。

在这段代码中，s 原先指向一个 String 对象，内容是 hello，然后我们对 s 进行 + 操作，那么 s 所指向的那个对象是否发生了变化呢？答案是没有，这时，s 不再指向原来的那个对象了，而指向另一个 String 对象，内容为 hello world，原来的那个对象还存在于内存中，只是 s 这个引用变量不再指向它了。如果经常对字符串进行各种各样的操作，或者说不可预见的修改，那么使用 String 对象来代表字符串的话会引起很大的内存的额外开销。因为 String 对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个 String 对象来表示。

## 18. 单例模式中的懒汉和饿汉模式的区别？

饿汉式是线程安全的，在类创建的同时就已经创建好一个静态的对象供系统使用，以后不在改变。

懒汉式如果在创建实例对象时不加上 synchronized 则会导致对对象的访问不是线程安全的，从实现方式来讲他们最大的区别就是懒汉式是延时加载, 他是在需要的时候才创建对象，而饿汉式在类创建的同时就已经创建好一个静态的对象供系统使用，以后不在改变。

```java
public class LazySingleton {
    //懒汉式单例模式:比较懒，在类加载时，不创建实例，因此类加载速度快，但运行时获取对象的速度慢
    private static LazySingleton intance = null;//静态私用成员，没有初始化
    private LazySingleton(){} //私有构造函数
    public static synchronized LazySingleton getInstance() { //静态，同步，公开访问点
        if (intance == null) {
            intance = new LazySingleton();
        }
        return intance;
    }
}
public class EagerSingleton {
    //饿汉单例模式:在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快
    private static EagerSingleton instance = new EagerSingleton();//静态私有成员，已初始化
    private EagerSingleton(){} //私有构造函数
    //静态，不用同步(类加载时已初始化，不会有多线程的问题）
    public static EagerSingleton getInstance(){
        return instance;
    }
}
```

## 19. 什么是事务？事务常见的并发问题及含义

事务是指逻辑上的一组操作，组成这组操作的一系列操作要么全部成功，要么全部失败。因此，事务的结束有两种，当事务中的所有操作全部成功执行时，事务提交。如果其中一个操作失败，将发生回滚操作，撤消到事务开始时的状态。

事务具有四个特征（ACID）：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。

**原子性**: 事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做 。

**一致性**: 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。

**隔离性**: 一个事务的执行不能被其它事务干扰。 

**持久性**: 指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。

事务并发问题：

- **脏读**：事务 A 读取了事务 B 更新、未提交的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据（没有用的数据）。
- **不可重复读**：事务 A 多次读取同一数据，结果读取的数据不一致，也就是说不支持重复读，重复读会有错误。原因是事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据不一致。
- **幻读**：事务 A 读取所有工资为5000的人数为10人。此时，事务 B 插入一条工资也为5000的记录。这时，事务 A 再次读取工资为5000的员工，记录为11人。此时产生了幻读。需要表锁才能隔离，所以大都数数据库都没有将幻读隔离。
- **注意**：不可重复读和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。

## 20. 你所了解的数据库优化都有哪些？

- **查询语句优化**：避免过多的表关联，注意 where 中的字段顺序，先过滤有索引的，能尽量缩小数据范围。
- **索引优化**：合理分析并设置、调整索引，索引过多也会增加数据库负担。
- **表结构优化**：如果数据量过大，纵向或者横向拆分表。纵向拆，将前n个字段放在一个表，后面m个放另一个表。横向：满足一定条件的数据放一个表，比如公司员工特别多，男雇员放一个，女雇员放一个表。
- **存储方式优化**：通过不同的存储空间或者表分区，将数据存放在不同的存储区域，达到充分利用IO的目的。

## 21. mysql 和 oracle 的区别？

- **主键**：MySql 一般使用自动增长类型，在创建表的时候只要指定表的主键为 auto increment，插入记录时就不需要再为主键添加记录了，主键会自动增长。Oracle 中没有自动增长，主键一般使用序列，插入记录时将序列号的下一值赋给该字段即可，ORM 框架只需要 native 主键生成策略即可。
- **分页查询**：MySql 中分页很简单，使用关键字 limit 来实现分页查询。但是 Oracle 里面没有这种关键字来实现分页查询的，所以它实现起来就比 MySql 要繁琐得多了，在每个结果集中只有一个 rownum 字段标明它的位置，并且只能用 rownum <=某个数，不能用 rownum >=某个数，因为 ROWNUM 是伪列，在使用时所以需要为 ROWNUM 取一个别名，变成逻辑列，然后来操作。
- **长字符串的处理**：Oracle 有它独特的地方，数据类型有一个 clob 类型，此类型专门用于在 insert 或者 update 时候字符串长度大于等于4000个单字节时使用。所以在插入记录前一定要进行非空和长度的判断，不能为空的或者长度超出的都应该提出警告，返回上次操作。MySql 就没有这样的数据类型。
- **修改表的数据**：Oracle 数据库在使用表的数据操作时，需要用 sql 语句来执行，比如：`select * from table for update;`这样你才能对数据进行修改，修改完了之后记得点击提交事务按钮。MySql中修改或添加数据就简单得多了，直接就可以设置数据，点击 refresh 保存就好。
- **数据库使用场景**：Oracle 是大型数据库而 Mysql 是中小型数据库，同时 Mysql 是开源的而 Oracle 价格非常高。Oracle 支持大并发，大访问量。

## 22. 左链接和右链接的语法及区别？

**左外连接**：用左边表的记录去匹配右边表的记录，如果符合条件的则显示；否则，显示 NULL 查询的是左表的全部以及右表中满足关联条件的数据。

**右外连接**：用右边表的记录去匹配左边表的记录，如果符合条件的则显示；否则，显示 NULL 查询的是右表的全部以及左表中满足关联条件的数据。

**等值连接**：通过 ON 关键字匹配两张表中满足条件的所有数据，如果不同则过滤。
